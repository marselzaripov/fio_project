import {
  AddChainError,
  ChainNotConfiguredError,
  Connector,
  ConnectorNotFoundError,
  InjectedConnector,
  ResourceUnavailableError,
  SwitchChainError,
  UserRejectedRequestError,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  connect,
  disconnect,
  getAccount,
  getClient,
  normalizeChainId,
  require_utils,
  watchAccount
} from "./chunk-S5KFPPEZ.js";
import {
  lib_exports21 as lib_exports
} from "./chunk-KIAPBSU3.js";
import "./chunk-3M2OLNY3.js";
import "./chunk-ZIH5MMVC.js";
import "./chunk-FFJMDCYD.js";
import {
  __toESM
} from "./chunk-FJLWZCXQ.js";

// node_modules/@wagmi/core/dist/connectors/coinbaseWallet.js
var import_utils = __toESM(require_utils());
var _client;
var _provider;
var _isUserRejectedRequestError;
var isUserRejectedRequestError_fn;
var CoinbaseWalletConnector = class extends Connector {
  constructor({ chains, options }) {
    super({
      chains,
      options: {
        reloadOnDisconnect: false,
        ...options
      }
    });
    __privateAdd(this, _isUserRejectedRequestError);
    this.id = "coinbaseWallet";
    this.name = "Coinbase Wallet";
    this.ready = true;
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _provider, void 0);
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: (0, import_utils.getAddress)(accounts[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", { chain: { id, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  async connect({ chainId } = {}) {
    try {
      const provider = await this.getProvider();
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      this.emit("message", { type: "connecting" });
      const accounts = await provider.enable();
      const account = (0, import_utils.getAddress)(accounts[0]);
      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);
      if (chainId && id !== chainId) {
        const chain = await this.switchChain(chainId);
        id = chain.id;
        unsupported = this.isChainUnsupported(id);
      }
      return {
        account,
        chain: { id, unsupported },
        provider: new lib_exports.Web3Provider(
          provider
        )
      };
    } catch (error) {
      if (/(user closed modal|accounts received is empty)/i.test(
        error.message
      ))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    if (!__privateGet(this, _provider))
      return;
    const provider = await this.getProvider();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    provider.disconnect();
    provider.close();
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return (0, import_utils.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  async getProvider() {
    var _a;
    if (!__privateGet(this, _provider)) {
      let CoinbaseWalletSDK = (await import("./dist-VXWFKWUM.js")).default;
      if (typeof CoinbaseWalletSDK !== "function" && typeof CoinbaseWalletSDK.default === "function")
        CoinbaseWalletSDK = CoinbaseWalletSDK.default;
      __privateSet(this, _client, new CoinbaseWalletSDK(this.options));
      class WalletProvider {
      }
      class Client {
      }
      const walletExtensionChainId = (_a = __privateGet(this, _client).walletExtension) == null ? void 0 : _a.getChainId();
      const chain = this.chains.find(
        (chain2) => this.options.chainId ? chain2.id === this.options.chainId : chain2.id === walletExtensionChainId
      ) || this.chains[0];
      const chainId = this.options.chainId || (chain == null ? void 0 : chain.id);
      const jsonRpcUrl = this.options.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default);
      __privateSet(this, _provider, __privateGet(this, _client).makeWeb3Provider(jsonRpcUrl, chainId));
    }
    return __privateGet(this, _provider);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    return new lib_exports.Web3Provider(
      provider,
      chainId
    ).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    var _a, _b;
    const provider = await this.getProvider();
    const id = (0, import_utils.hexValue)(chainId);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id }]
      });
      return (_a = this.chains.find((x) => x.id === chainId)) != null ? _a : {
        id: chainId,
        name: `Chain ${id}`,
        network: `${id}`,
        rpcUrls: { default: "" }
      };
    } catch (error) {
      const chain = this.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new ChainNotConfiguredError({ chainId, connectorId: this.id });
      if (error.code === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id,
                chainName: chain.name,
                nativeCurrency: chain.nativeCurrency,
                rpcUrls: [(_b = chain.rpcUrls.public) != null ? _b : chain.rpcUrls.default],
                blockExplorerUrls: this.getBlockExplorerUrls(chain)
              }
            ]
          });
          return chain;
        } catch (addError) {
          if (__privateMethod(this, _isUserRejectedRequestError, isUserRejectedRequestError_fn).call(this, addError))
            throw new UserRejectedRequestError(addError);
          throw new AddChainError();
        }
      }
      if (__privateMethod(this, _isUserRejectedRequestError, isUserRejectedRequestError_fn).call(this, error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
};
_client = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_isUserRejectedRequestError = /* @__PURE__ */ new WeakSet();
isUserRejectedRequestError_fn = function(error) {
  return /(user rejected)/i.test(error.message);
};

// node_modules/@wagmi/core/dist/connectors/metaMask.js
var _provider2;
var _UNSTABLE_shimOnConnectSelectAccount;
var _getReady;
var getReady_fn;
var _findProvider;
var findProvider_fn;
var MetaMaskConnector = class extends InjectedConnector {
  constructor({
    chains,
    options: options_
  } = {}) {
    const options = {
      name: "MetaMask",
      shimDisconnect: true,
      shimChainChangedDisconnect: true,
      ...options_
    };
    super({ chains, options });
    __privateAdd(this, _getReady);
    __privateAdd(this, _findProvider);
    this.id = "metaMask";
    this.ready = typeof window != "undefined" && !!__privateMethod(this, _findProvider, findProvider_fn).call(this, window.ethereum);
    __privateAdd(this, _provider2, void 0);
    __privateAdd(this, _UNSTABLE_shimOnConnectSelectAccount, void 0);
    __privateSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);
  }
  async connect({ chainId } = {}) {
    var _a, _b, _c, _d;
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      if (__privateGet(this, _UNSTABLE_shimOnConnectSelectAccount) && ((_a = this.options) == null ? void 0 : _a.shimDisconnect) && !((_b = getClient().storage) == null ? void 0 : _b.getItem(this.shimDisconnectKey))) {
        const accounts = await provider.request({
          method: "eth_accounts"
        }).catch(() => []);
        const isConnected = !!accounts[0];
        if (isConnected)
          await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
      }
      const account = await this.getAccount();
      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);
      if (chainId && id !== chainId) {
        const chain = await this.switchChain(chainId);
        id = chain.id;
        unsupported = this.isChainUnsupported(id);
      }
      if ((_c = this.options) == null ? void 0 : _c.shimDisconnect)
        (_d = getClient().storage) == null ? void 0 : _d.setItem(this.shimDisconnectKey, true);
      return { account, chain: { id, unsupported }, provider };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
  async getProvider() {
    if (typeof window !== "undefined") {
      __privateSet(this, _provider2, __privateMethod(this, _findProvider, findProvider_fn).call(this, window.ethereum));
    }
    return __privateGet(this, _provider2);
  }
};
_provider2 = /* @__PURE__ */ new WeakMap();
_UNSTABLE_shimOnConnectSelectAccount = /* @__PURE__ */ new WeakMap();
_getReady = /* @__PURE__ */ new WeakSet();
getReady_fn = function(ethereum) {
  const isMetaMask = !!(ethereum == null ? void 0 : ethereum.isMetaMask);
  if (!isMetaMask)
    return;
  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state)
    return;
  if (ethereum.isAvalanche)
    return;
  if (ethereum.isKuCoinWallet)
    return;
  if (ethereum.isPortal)
    return;
  if (ethereum.isTokenPocket)
    return;
  if (ethereum.isTokenary)
    return;
  return ethereum;
};
_findProvider = /* @__PURE__ */ new WeakSet();
findProvider_fn = function(ethereum) {
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find(__privateMethod(this, _getReady, getReady_fn));
  return __privateMethod(this, _getReady, getReady_fn).call(this, ethereum);
};

// node_modules/@wagmi/core/dist/connectors/walletConnect.js
var import_utils2 = __toESM(require_utils());
var switchChainAllowedRegex = /(imtoken|metamask|rainbow|trust wallet)/i;
var _provider3;
var _switchChain;
var switchChain_fn;
var WalletConnectConnector = class extends Connector {
  constructor(config) {
    super(config);
    __privateAdd(this, _switchChain);
    this.id = "walletConnect";
    this.name = "WalletConnect";
    this.ready = true;
    __privateAdd(this, _provider3, void 0);
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: (0, import_utils2.getAddress)(accounts[0]) });
    };
    this.onChainChanged = (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", { chain: { id, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  async connect({ chainId } = {}) {
    var _a, _b, _c;
    try {
      let targetChainId = chainId;
      if (!targetChainId) {
        const lastUsedChainId = getClient().lastUsedChainId;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
      }
      const provider = await this.getProvider({
        chainId: targetChainId,
        create: true
      });
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      setTimeout(() => this.emit("message", { type: "connecting" }), 0);
      const accounts = await provider.enable();
      const account = (0, import_utils2.getAddress)(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      const walletName = (_c = (_b = (_a = provider.connector) == null ? void 0 : _a.peerMeta) == null ? void 0 : _b.name) != null ? _c : "";
      if (switchChainAllowedRegex.test(walletName))
        this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);
      return {
        account,
        chain: { id, unsupported },
        provider: new lib_exports.Web3Provider(
          provider
        )
      };
    } catch (error) {
      if (/user closed modal/i.test(error.message))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    await provider.disconnect();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = provider.accounts;
    return (0, import_utils2.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId = normalizeChainId(provider.chainId);
    return chainId;
  }
  async getProvider({
    chainId,
    create
  } = {}) {
    var _a, _b;
    if (!__privateGet(this, _provider3) || chainId || create) {
      const rpc = !((_a = this.options) == null ? void 0 : _a.infuraId) ? this.chains.reduce(
        (rpc2, chain) => ({ ...rpc2, [chain.id]: chain.rpcUrls.default }),
        {}
      ) : {};
      const WalletConnectProvider = (await import("./esm-LHVQNXKK.js")).default;
      __privateSet(this, _provider3, new WalletConnectProvider({
        ...this.options,
        chainId,
        rpc: { ...rpc, ...(_b = this.options) == null ? void 0 : _b.rpc }
      }));
    }
    return __privateGet(this, _provider3);
  }
  async getSigner({ chainId } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId }),
      this.getAccount()
    ]);
    return new lib_exports.Web3Provider(
      provider,
      chainId
    ).getSigner(account);
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
};
_provider3 = /* @__PURE__ */ new WeakMap();
_switchChain = /* @__PURE__ */ new WeakSet();
switchChain_fn = async function(chainId) {
  var _a;
  const provider = await this.getProvider();
  const id = (0, import_utils2.hexValue)(chainId);
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: id }]
    });
    return (_a = this.chains.find((x) => x.id === chainId)) != null ? _a : {
      id: chainId,
      name: `Chain ${id}`,
      network: `${id}`,
      rpcUrls: { default: "" }
    };
  } catch (error) {
    const message = typeof error === "string" ? error : error == null ? void 0 : error.message;
    if (/user rejected request/i.test(message))
      throw new UserRejectedRequestError(error);
    throw new SwitchChainError(error);
  }
};

// node_modules/@wagmi/core/dist/providers/jsonRpc.js
function jsonRpcProvider({
  priority,
  rpc,
  stallTimeout,
  static: static_ = true,
  weight
}) {
  return function(chain) {
    const rpcConfig = rpc(chain);
    if (!rpcConfig || rpcConfig.http === "")
      return null;
    return {
      chain: {
        ...chain,
        rpcUrls: {
          ...chain.rpcUrls,
          default: rpcConfig.http
        }
      },
      provider: () => {
        var _a;
        const RpcProvider = static_ ? lib_exports.StaticJsonRpcProvider : lib_exports.JsonRpcProvider;
        const provider = new RpcProvider(rpcConfig.http, {
          ensAddress: (_a = chain.ens) == null ? void 0 : _a.address,
          chainId: chain.id,
          name: chain.network
        });
        return Object.assign(provider, { priority, stallTimeout, weight });
      },
      ...rpcConfig.webSocket && {
        webSocketProvider: () => new lib_exports.WebSocketProvider(
          rpcConfig.webSocket,
          chain.id
        )
      }
    };
  };
}

// node_modules/@web3modal/ethereum/dist/index.js
var B = class {
  constructor(n, e) {
    this.wagmi = {}, this.chains = [], this.disconnect = disconnect, this.getAccount = getAccount, this.watchAccount = watchAccount, this.wagmi = n, this.chains = e;
  }
  getDefaultConnectorChainId(n) {
    return n.chains[0].id;
  }
  getConnectorById(n) {
    const e = this.wagmi.connectors.find((t) => t.id === n);
    if (!e)
      throw new Error(`Missing ${n} connector`);
    return e;
  }
  async getActiveWalletConnectUri() {
    return (await this.getConnectorById("walletConnect").getProvider()).connector.uri;
  }
  async connectWalletConnect(n, e) {
    const t = this.getConnectorById("walletConnect"), o = e != null ? e : this.getDefaultConnectorChainId(t);
    async function i() {
      return new Promise((s) => {
        t.once("message", async ({ type: a }) => {
          if (a === "connecting") {
            const h = await t.getProvider();
            n(h.connector.uri), s();
          }
        });
      });
    }
    const [r] = await Promise.all([connect({ connector: t, chainId: o }), i()]);
    return r;
  }
  async connectCoinbaseMobile(n, e) {
    const t = this.getConnectorById("coinbaseWallet"), o = e != null ? e : this.getDefaultConnectorChainId(t);
    async function i() {
      return new Promise((s) => {
        t.once("message", async ({ type: a }) => {
          if (a === "connecting") {
            const h = await t.getProvider();
            n == null ? void 0 : n(h.qrUrl), s();
          }
        });
      });
    }
    const [r] = await Promise.all([connect({ connector: t, chainId: o }), i()]);
    return r;
  }
  async connectExtension(n, e) {
    const t = this.getConnectorById(n), o = e != null ? e : this.getDefaultConnectorChainId(t);
    return await connect({ connector: t, chainId: o });
  }
};
var I = "eip155";
function M({ projectId: c }) {
  return jsonRpcProvider({ rpc: (n) => ({ http: `https://rpc.walletconnect.com/v1/?chainId=${I}:${n.id}&projectId=${c}` }) });
}
function W({ appName: c, chains: n }) {
  return [new WalletConnectConnector({ chains: n, options: { qrcode: false } }), new InjectedConnector({ chains: n, options: { shimDisconnect: true } }), new CoinbaseWalletConnector({ chains: n, options: { appName: c, headlessMode: true } }), new MetaMaskConnector({ chains: n, options: { shimDisconnect: true, shimChainChangedDisconnect: false, UNSTABLE_shimOnConnectSelectAccount: true } })];
}
export {
  B as EthereumClient,
  W as modalConnectors,
  M as walletConnectProvider
};
//# sourceMappingURL=@web3modal_ethereum.js.map
