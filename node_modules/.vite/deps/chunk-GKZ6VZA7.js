import {
  require_buffer
} from "./chunk-ECI2YFJC.js";
import {
  __toESM
} from "./chunk-FJLWZCXQ.js";

// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var r = Symbol();
var o = Object.getPrototypeOf;
var s = /* @__PURE__ */ new WeakMap();
var c = (e2) => e2 && (s.has(e2) ? s.get(e2) : o(e2) === Object.prototype || o(e2) === Array.prototype);
var g = (e2) => c(e2) && e2[r] || null;
var b = (e2, t2 = true) => {
  s.set(e2, t2);
};

// node_modules/valtio/esm/vanilla.mjs
var isObject = (x) => typeof x === "object" && x !== null;
var PROXY_STATE = Symbol();
var refSet = /* @__PURE__ */ new WeakSet();
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, receiver, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(receiver);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  b(snap, true);
  snapCache.set(receiver, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key, receiver);
    if (refSet.has(value)) {
      b(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (value == null ? void 0 : value[PROXY_STATE]) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = /* @__PURE__ */ new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    get(target, prop, receiver) {
      if (prop === PROXY_STATE) {
        const state = [
          target,
          receiver,
          version,
          createSnapshot,
          listeners
        ];
        return state;
      }
      return Reflect.get(target, prop, receiver);
    },
    deleteProperty(target, prop) {
      var _a;
      const prevValue = Reflect.get(target, prop);
      const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a, _b;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && objectIs(prevValue, value)) {
        return true;
      }
      const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (isObject(value)) {
        value = g(value) || value;
      }
      let nextValue = value;
      if ((_b = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _b.set)
        ;
      else if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!(value == null ? void 0 : value[PROXY_STATE]) && canProxy(value)) {
          nextValue = proxy(value);
        }
        if (nextValue == null ? void 0 : nextValue[PROXY_STATE]) {
          nextValue[PROXY_STATE][4].add(
            getPropListener(prop)
          );
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  proxyFunction2,
  PROXY_STATE,
  refSet,
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const listeners = proxyObject[PROXY_STATE][4];
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (listeners.has(listener)) {
          callback(ops.splice(0));
        }
      });
    }
  };
  listeners.add(listener);
  return () => listeners.delete(listener);
}
function snapshot(proxyObject, handlePromise) {
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
    console.warn("Please use proxy object");
  }
  const [target, receiver, version, createSnapshot] = proxyObject[PROXY_STATE];
  return createSnapshot(target, receiver, version, handlePromise);
}

// node_modules/@web3modal/core/dist/index.js
var import_buffer = __toESM(require_buffer());
var c2 = proxy({ selectedChainId: void 0, chains: void 0, standaloneChains: void 0, standaloneUri: void 0 });
var h = { state: c2, setChains(e2) {
  c2.chains = e2;
}, setStandaloneChains(e2) {
  c2.standaloneChains = e2;
}, setStandaloneUri(e2) {
  c2.standaloneUri = e2;
}, setSelectedChainId(e2) {
  c2.selectedChainId = e2;
} };
var d = proxy({ initialized: false, ethereumClient: void 0 });
var S = { setEthereumClient(e2) {
  !d.initialized && e2 && (d.ethereumClient = e2, h.setChains(e2.chains), d.initialized = true);
}, client() {
  if (d.ethereumClient)
    return d.ethereumClient;
  throw new Error("ClientCtrl has no client set");
} };
function y() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
var p = proxy({ configured: false, projectId: "", theme: y() ? "dark" : "light", accentColor: "default", standaloneChains: void 0 });
var O = { state: p, subscribe(e2) {
  return subscribe(p, () => e2(p));
}, setConfig(e2) {
  var t2;
  if (!e2.projectId)
    throw new Error("Web3Modal requires projectId that can be obtained at cloud.walletconnect.com");
  (t2 = e2.standaloneChains) != null && t2.length && h.setStandaloneChains(e2.standaloneChains), Object.assign(p, e2), p.configured = true;
} };
function W(e2) {
  const t2 = Object.fromEntries(Object.entries(e2).filter(([o2, n]) => typeof n < "u" && n !== null && n !== "").map(([o2, n]) => [o2, n.toString()]));
  return new URLSearchParams(t2).toString();
}
function j() {
  return { url: "https://explorer-api.walletconnect.com", projectId: O.state.projectId };
}
async function C(e2) {
  const { url: t2, projectId: o2 } = j(), n = `${t2}/v3/wallets?projectId=${o2}&${W(e2)}`;
  return (await fetch(n)).json();
}
var a = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, previewWallets: [], recomendedWallets: [] });
var P = { state: a, subscribe(e2) {
  return subscribe(a, () => e2(a));
}, async getPreviewWallets(e2) {
  const { listings: t2 } = await C(e2);
  return a.previewWallets = Object.values(t2), a.previewWallets;
}, async getRecomendedWallets() {
  const { listings: e2 } = await C({ page: 1, entries: 6 });
  a.recomendedWallets = Object.values(e2);
}, async getPaginatedWallets(e2) {
  const { page: t2, search: o2 } = e2, { listings: n, total: l } = await C(e2), g2 = Object.values(n), f = o2 ? "search" : "wallets";
  return a[f] = { listings: [...a[f].listings, ...g2], total: l, page: t2 != null ? t2 : 1 }, { listings: g2, total: l };
}, resetSearch() {
  a.search = { listings: [], total: 0, page: 1 };
} };
var s2 = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
var m = { state: s2, subscribe(e2) {
  return subscribe(s2, () => e2(s2));
}, push(e2, t2) {
  e2 !== s2.view && (s2.view = e2, t2 && (s2.data = t2), s2.history.push(e2));
}, replace(e2) {
  s2.view = e2, s2.history = [e2];
}, goBack() {
  if (s2.history.length > 1) {
    s2.history.pop();
    const [e2] = s2.history.slice(-1);
    s2.view = e2;
  }
} };
var u = proxy({ open: false });
var L = { state: u, subscribe(e2) {
  return subscribe(u, () => e2(u));
}, open(e2) {
  var t2;
  const { chains: o2 } = h.state;
  o2 != null && o2.length && o2.length > 1 ? m.replace("SelectNetwork") : m.replace("ConnectWallet"), typeof (e2 == null ? void 0 : e2.uri) == "string" && h.setStandaloneUri(e2.uri), (t2 = e2 == null ? void 0 : e2.standaloneChains) != null && t2.length && h.setStandaloneChains(e2.standaloneChains), u.open = true;
}, close() {
  u.open = false;
} };
var r2 = proxy({ open: false, message: "", variant: "success" });
var N = { state: r2, subscribe(e2) {
  return subscribe(r2, () => e2(r2));
}, openToast(e2, t2) {
  r2.open = true, r2.message = e2, r2.variant = t2;
}, closeToast() {
  r2.open = false;
} };
var b2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var $ = { isCoinbaseExtension() {
  return window.coinbaseWalletExtension;
}, isMobile() {
  return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
}, isEmptyObject(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.getOwnPropertyNames(e2).length === 0 && Object.getOwnPropertySymbols(e2).length === 0;
}, formatNativeUrl(e2, t2, o2) {
  const n = e2.replaceAll("/", "").replaceAll(":", "");
  this.setWalletConnectDeepLink(n, o2);
  const l = encodeURIComponent(t2);
  return `${n}://wc?uri=${l}`;
}, formatUniversalUrl(e2, t2, o2) {
  let n = e2;
  e2.endsWith("/") && (n = e2.slice(0, -1)), this.setWalletConnectDeepLink(n, o2);
  const l = encodeURIComponent(t2);
  return `${n}/wc?uri=${l}`;
}, async wait(e2) {
  return new Promise((t2) => {
    setTimeout(t2, e2);
  });
}, openHref(e2, t2 = "_self") {
  window.open(e2, t2, "noreferrer noopener");
}, setWalletConnectDeepLink(e2, t2) {
  localStorage.setItem(b2, JSON.stringify({ href: e2, name: t2 }));
}, removeWalletConnectDeepLink() {
  localStorage.removeItem(b2);
}, isNull(e2) {
  return e2 === null;
} };
typeof window < "u" && (window.Buffer || (window.Buffer = import_buffer.Buffer), window.global || (window.global = window), window.process || (window.process = { env: {} }));

export {
  h,
  S,
  O,
  j,
  P,
  m,
  L,
  N,
  $
};
//# sourceMappingURL=chunk-GKZ6VZA7.js.map
