import {
  BigNumber,
  Contract,
  init_lib,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib13,
  init_lib14,
  init_lib15,
  init_lib16,
  init_lib17,
  init_lib18,
  init_lib19,
  init_lib2,
  init_lib20,
  init_lib21,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  lib_exports,
  lib_exports10 as lib_exports9,
  lib_exports11 as lib_exports10,
  lib_exports12 as lib_exports11,
  lib_exports13 as lib_exports12,
  lib_exports14 as lib_exports13,
  lib_exports15 as lib_exports14,
  lib_exports16 as lib_exports15,
  lib_exports17 as lib_exports16,
  lib_exports18 as lib_exports17,
  lib_exports19 as lib_exports18,
  lib_exports2,
  lib_exports20 as lib_exports19,
  lib_exports21 as lib_exports20,
  lib_exports22 as lib_exports21,
  lib_exports23 as lib_exports22,
  lib_exports3,
  lib_exports4,
  lib_exports5,
  lib_exports6,
  lib_exports8 as lib_exports7,
  lib_exports9 as lib_exports8
} from "./chunk-KIAPBSU3.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-FJLWZCXQ.js";

// node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib10(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib6(), __toCommonJS(lib_exports6));
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib8(), __toCommonJS(lib_exports8)));
    exports.base64 = base64;
    var basex_1 = (init_lib13(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib15(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib4(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib20(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib16(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib3(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib5(), __toCommonJS(lib_exports5)));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib11(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib12(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib21(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib18(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib19(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/@wagmi/core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@wagmi/core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@wagmi/core/dist/chunk-4DNFSL2K.js
var etherscanBlockExplorers = {
  mainnet: {
    name: "Etherscan",
    url: "https://etherscan.io"
  },
  goerli: {
    name: "Etherscan",
    url: "https://goerli.etherscan.io"
  },
  sepolia: {
    name: "Etherscan",
    url: "https://sepolia.etherscan.io"
  },
  optimism: {
    name: "Etherscan",
    url: "https://optimistic.etherscan.io"
  },
  optimismGoerli: {
    name: "Etherscan",
    url: "https://goerli-optimism.etherscan.io"
  },
  polygon: {
    name: "PolygonScan",
    url: "https://polygonscan.com"
  },
  polygonMumbai: {
    name: "PolygonScan",
    url: "https://mumbai.polygonscan.com"
  },
  arbitrum: { name: "Arbiscan", url: "https://arbiscan.io" },
  arbitrumGoerli: { name: "Arbiscan", url: "https://goerli.arbiscan.io" }
};
var alchemyRpcUrls = {
  mainnet: "https://eth-mainnet.alchemyapi.io/v2",
  goerli: "https://eth-goerli.alchemyapi.io/v2",
  optimism: "https://opt-mainnet.g.alchemy.com/v2",
  optimismGoerli: "https://opt-goerli.g.alchemy.com/v2",
  polygon: "https://polygon-mainnet.g.alchemy.com/v2",
  polygonMumbai: "https://polygon-mumbai.g.alchemy.com/v2",
  arbitrum: "https://arb-mainnet.g.alchemy.com/v2",
  arbitrumGoerli: "https://arb-goerli.g.alchemy.com/v2"
};
var infuraRpcUrls = {
  mainnet: "https://mainnet.infura.io/v3",
  goerli: "https://goerli.infura.io/v3",
  sepolia: "https://sepolia.infura.io/v3",
  optimism: "https://optimism-mainnet.infura.io/v3",
  optimismGoerli: "https://optimism-goerli.infura.io/v3",
  polygon: "https://polygon-mainnet.infura.io/v3",
  polygonMumbai: "https://polygon-mumbai.infura.io/v3",
  arbitrum: "https://arbitrum-mainnet.infura.io/v3",
  arbitrumGoerli: "https://arbitrum-goerli.infura.io/v3"
};
var publicRpcUrls = {
  mainnet: "https://cloudflare-eth.com",
  goerli: "https://rpc.ankr.com/eth_goerli",
  sepolia: "https://rpc.sepolia.org",
  optimism: "https://mainnet.optimism.io",
  optimismGoerli: "https://goerli.optimism.io",
  polygon: "https://polygon-rpc.com",
  polygonMumbai: "https://matic-mumbai.chainstacklabs.com",
  arbitrum: "https://arb1.arbitrum.io/rpc",
  arbitrumGoerli: "https://goerli-rollup.arbitrum.io/rpc"
};
var chainId = {
  mainnet: 1,
  goerli: 5,
  sepolia: 11155111,
  optimism: 10,
  optimismGoerli: 420,
  polygon: 137,
  polygonMumbai: 80001,
  arbitrum: 42161,
  arbitrumGoerli: 421613,
  localhost: 1337,
  hardhat: 31337,
  foundry: 31337
};
var mainnet = {
  id: chainId.mainnet,
  name: "Ethereum",
  network: "homestead",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: alchemyRpcUrls.mainnet,
    default: publicRpcUrls.mainnet,
    infura: infuraRpcUrls.mainnet,
    public: publicRpcUrls.mainnet
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.mainnet,
    default: etherscanBlockExplorers.mainnet
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 14353601
  }
};
var goerli = {
  id: chainId.goerli,
  name: "Goerli",
  network: "goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: alchemyRpcUrls.goerli,
    default: publicRpcUrls.goerli,
    infura: infuraRpcUrls.goerli,
    public: publicRpcUrls.goerli
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.goerli,
    default: etherscanBlockExplorers.goerli
  },
  ens: {
    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 6507670
  },
  testnet: true
};
var sepolia = {
  id: chainId.sepolia,
  name: "Sepolia",
  network: "sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: publicRpcUrls.sepolia,
    infura: infuraRpcUrls.sepolia,
    public: publicRpcUrls.sepolia
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.sepolia,
    default: etherscanBlockExplorers.sepolia
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 751532
  },
  testnet: true
};
var optimism = {
  id: chainId.optimism,
  name: "Optimism",
  network: "optimism",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: alchemyRpcUrls.optimism,
    default: publicRpcUrls.optimism,
    infura: infuraRpcUrls.optimism,
    public: publicRpcUrls.optimism
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.optimism,
    default: etherscanBlockExplorers.optimism
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 4286263
  }
};
var optimismGoerli = {
  id: chainId.optimismGoerli,
  name: "Optimism Goerli",
  network: "optimism-goerli",
  nativeCurrency: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.optimismGoerli,
    default: publicRpcUrls.optimismGoerli,
    infura: infuraRpcUrls.optimismGoerli,
    public: publicRpcUrls.optimismGoerli
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.optimismGoerli,
    default: etherscanBlockExplorers.optimismGoerli
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 49461
  },
  testnet: true
};
var polygon = {
  id: chainId.polygon,
  name: "Polygon",
  network: "matic",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    alchemy: alchemyRpcUrls.polygon,
    default: publicRpcUrls.polygon,
    infura: infuraRpcUrls.polygon,
    public: publicRpcUrls.polygon
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.polygon,
    default: etherscanBlockExplorers.polygon
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 25770160
  }
};
var polygonMumbai = {
  id: chainId.polygonMumbai,
  name: "Polygon Mumbai",
  network: "maticmum",
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.polygonMumbai,
    default: publicRpcUrls.polygonMumbai,
    infura: infuraRpcUrls.polygonMumbai,
    public: publicRpcUrls.polygonMumbai
  },
  blockExplorers: {
    etherscan: etherscanBlockExplorers.polygonMumbai,
    default: etherscanBlockExplorers.polygonMumbai
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 25444704
  },
  testnet: true
};
var arbitrum = {
  id: chainId.arbitrum,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: alchemyRpcUrls.arbitrum,
    default: publicRpcUrls.arbitrum,
    infura: infuraRpcUrls.arbitrum,
    public: publicRpcUrls.arbitrum
  },
  blockExplorers: {
    arbitrum: {
      name: "Arbitrum Explorer",
      url: "https://explorer.arbitrum.io"
    },
    etherscan: etherscanBlockExplorers.arbitrum,
    default: etherscanBlockExplorers.arbitrum
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 7654707
  }
};
var arbitrumGoerli = {
  id: chainId.arbitrumGoerli,
  name: "Arbitrum Goerli",
  network: "arbitrum-goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    alchemy: alchemyRpcUrls.arbitrumGoerli,
    default: publicRpcUrls.arbitrumGoerli,
    infura: infuraRpcUrls.arbitrumGoerli,
    public: publicRpcUrls.arbitrumGoerli
  },
  blockExplorers: {
    arbitrum: {
      name: "Arbitrum Explorer",
      url: "https://goerli-rollup-explorer.arbitrum.io"
    },
    etherscan: etherscanBlockExplorers.arbitrumGoerli,
    default: etherscanBlockExplorers.arbitrumGoerli
  },
  multicall: {
    address: "0xca11bde05977b3631167028862be2a173976ca11",
    blockCreated: 88114
  },
  testnet: true
};
var localhost = {
  id: chainId.localhost,
  name: "Localhost",
  network: "localhost",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var hardhat = {
  id: chainId.hardhat,
  name: "Hardhat",
  network: "hardhat",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var foundry = {
  id: chainId.foundry,
  name: "Foundry",
  network: "foundry",
  rpcUrls: {
    default: "http://127.0.0.1:8545"
  }
};
var chain = {
  mainnet,
  goerli,
  sepolia,
  optimism,
  optimismGoerli,
  polygon,
  polygonMumbai,
  arbitrum,
  arbitrumGoerli,
  localhost,
  hardhat,
  foundry
};
var allChains = [
  mainnet,
  goerli,
  sepolia,
  optimism,
  optimismGoerli,
  polygon,
  polygonMumbai,
  arbitrum,
  arbitrumGoerli,
  localhost,
  hardhat,
  foundry
];
var defaultChains = [mainnet, goerli];
var defaultL2Chains = [
  arbitrum,
  arbitrumGoerli,
  optimism,
  optimismGoerli
];

// node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/zustand/esm/middleware.mjs
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;
var toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
var persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e) {
  }
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e) => {
      errorInSync = e;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
var persist = persistImpl;

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@wagmi/core/dist/chunk-FJTAQ7YO.js
var import_utils = __toESM(require_utils(), 1);
var import_utils2 = __toESM(require_utils(), 1);
var import_utils3 = __toESM(require_utils(), 1);
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
var import_utils4 = __toESM(require_utils(), 1);
var import_utils5 = __toESM(require_utils(), 1);

// node_modules/zustand/esm/shallow.mjs
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@wagmi/core/dist/chunk-FJTAQ7YO.js
var import_utils6 = __toESM(require_utils(), 1);
var import_utils7 = __toESM(require_utils(), 1);
var import_utils8 = __toESM(require_utils(), 1);
var import_utils9 = __toESM(require_utils(), 1);
function configureChains(defaultChains2, providers3, {
  minQuorum = 1,
  pollingInterval = 4e3,
  targetQuorum = 1,
  stallTimeout
} = {}) {
  if (!defaultChains2.length)
    throw new Error("must have at least one chain");
  if (targetQuorum < minQuorum)
    throw new Error("quorum cannot be lower than minQuorum");
  let chains = [];
  const providers_ = {};
  const webSocketProviders_ = {};
  for (const chain2 of defaultChains2) {
    let configExists = false;
    for (const provider of providers3) {
      const apiConfig = provider(chain2);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains.some(({ id }) => id === chain2.id)) {
        chains = [...chains, apiConfig.chain];
      }
      providers_[chain2.id] = [
        ...providers_[chain2.id] || [],
        apiConfig.provider
      ];
      if (apiConfig.webSocketProvider) {
        webSocketProviders_[chain2.id] = [
          ...webSocketProviders_[chain2.id] || [],
          apiConfig.webSocketProvider
        ];
      }
    }
    if (!configExists) {
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${chain2.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/docs/providers/jsonRpc"
        ].join("\n")
      );
    }
  }
  return {
    chains,
    provider: ({ chainId: chainId2 }) => {
      var _a;
      const activeChain = (_a = chains.find((x) => x.id === chainId2)) != null ? _a : defaultChains2[0];
      const chainProviders = providers_[activeChain.id];
      if (!chainProviders || !chainProviders[0])
        throw new Error(`No providers configured for chain "${activeChain.id}"`);
      let provider;
      if (chainProviders.length === 1) {
        provider = chainProviders[0]();
      } else {
        provider = fallbackProvider(targetQuorum, minQuorum, chainProviders, {
          stallTimeout
        });
      }
      if (activeChain.id === 42220) {
        provider.formatter.formats.block = {
          ...provider.formatter.formats.block,
          difficulty: () => 0,
          gasLimit: () => 0
        };
      }
      return Object.assign(provider, {
        chains,
        pollingInterval
      });
    },
    webSocketProvider: ({ chainId: chainId2 }) => {
      var _a, _b;
      const activeChain = (_a = chains.find((x) => x.id === chainId2)) != null ? _a : defaultChains2[0];
      const chainWebSocketProviders = webSocketProviders_[activeChain.id];
      if (!chainWebSocketProviders)
        return void 0;
      const provider = (_b = chainWebSocketProviders[0]) == null ? void 0 : _b.call(chainWebSocketProviders);
      if (provider && activeChain.id === 42220) {
        provider.formatter.formats.block = {
          ...provider.formatter.formats.block,
          difficulty: () => 0,
          gasLimit: () => 0
        };
      }
      return Object.assign(provider || {}, {
        chains
      });
    }
  };
}
function fallbackProvider(targetQuorum, minQuorum, providers_, { stallTimeout }) {
  var _a;
  try {
    return new lib_exports20.FallbackProvider(
      providers_.map((chainProvider, index) => {
        var _a2, _b;
        const provider = chainProvider();
        return {
          provider,
          priority: (_a2 = provider.priority) != null ? _a2 : index,
          stallTimeout: (_b = provider.stallTimeout) != null ? _b : stallTimeout,
          weight: provider.weight
        };
      }),
      targetQuorum
    );
  } catch (error) {
    if ((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes(
      "quorum will always fail; larger than total weight"
    )) {
      if (targetQuorum === minQuorum)
        throw error;
      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {
        stallTimeout
      });
    }
    throw error;
  }
}
function assertActiveChain({
  chainId: chainId2,
  signer
}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { chain: activeChain, chains } = getNetwork();
  const activeChainId = activeChain == null ? void 0 : activeChain.id;
  if (activeChainId && chainId2 !== activeChainId) {
    throw new ChainMismatchError({
      activeChain: (_b = (_a = chains.find((x) => x.id === activeChainId)) == null ? void 0 : _a.name) != null ? _b : `Chain ${activeChainId}`,
      targetChain: (_d = (_c = chains.find((x) => x.id === chainId2)) == null ? void 0 : _c.name) != null ? _d : `Chain ${chainId2}`
    });
  }
  if (signer) {
    const signerChainId = (_f = (_e = signer.provider) == null ? void 0 : _e.network) == null ? void 0 : _f.chainId;
    if (signerChainId && chainId2 !== signerChainId) {
      const connector = getClient().connector;
      throw new ChainNotConfiguredError({
        chainId: chainId2,
        connectorId: (_g = connector == null ? void 0 : connector.id) != null ? _g : "unknown"
      });
    }
  }
}
function debounce(fn, waitTime = 0) {
  let timeout;
  return function(...args) {
    if (!waitTime)
      return fn(...args);
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      fn(...args);
    }, waitTime);
  };
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a) && Array.isArray(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return false;
      return true;
    }
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    const keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key && !deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
function normalizeFunctionName({
  contract,
  functionName,
  args = []
}) {
  var _a;
  if (functionName in contract.functions)
    return functionName;
  const argsLength = (_a = args == null ? void 0 : args.length) != null ? _a : 0;
  const overloadFunctions = Object.keys(contract.functions).filter((x) => x.startsWith(`${functionName}(`)).map((x) => ({ name: x, fragment: import_utils2.FunctionFragment.fromString(x) })).filter((x) => argsLength === x.fragment.inputs.length);
  for (const overloadFunction of overloadFunctions) {
    const matched = args.every((arg, index) => {
      const abiParameter = overloadFunction.fragment.inputs[index];
      return isArgOfType(arg, abiParameter);
    });
    if (matched)
      return overloadFunction.name;
  }
  return functionName;
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return (0, import_utils2.isAddress)(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every(
          (component, index) => {
            return isArgOfType(
              Object.values(arg)[index],
              component
            );
          }
        );
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
        abiParameterType
      ))
        return argType === "number" || argType === "bigint" || BigNumber.isBigNumber(arg);
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every(
          (x) => isArgOfType(x, {
            ...abiParameter,
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          })
        );
      }
      return false;
    }
  }
}
function getInjectedName(ethereum) {
  var _a, _b, _c;
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isAvalanche)
      return "Core Wallet";
    if (provider.isBitKeep)
      return "BitKeep";
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFrame)
      return "Frame";
    if (provider.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider.isMathWallet)
      return "MathWallet";
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider.isOpera)
      return "Opera";
    if (provider.isPortal)
      return "Ripio Portal";
    if (provider.isTally)
      return "Tally";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust || provider.isTrustWallet)
      return "Trust Wallet";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if ((_a = ethereum.providers) == null ? void 0 : _a.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name = getName(provider);
      if (!name) {
        name = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name);
    }
    const names = [...nameSet];
    if (names.length)
      return names;
    return (_b = names[0]) != null ? _b : "Injected";
  }
  return (_c = getName(ethereum)) != null ? _c : "Injected";
}
function logWarn(message) {
  var _a, _b, _c;
  (_c = (_b = (_a = getClient()) == null ? void 0 : _a.config.logger) == null ? void 0 : _b.warn) == null ? void 0 : _c.call(_b, message);
}
function minimizeContractInterface(config) {
  try {
    const minimizedAbi = config.abi.filter(
      (x) => x.type === "function" && x.name === config.functionName
    );
    if (minimizedAbi.length === 0)
      throw new Error("Invalid ABI");
    return minimizedAbi;
  } catch (error) {
    const abi = Contract.getInterface(config.abi).format(
      import_utils3.FormatTypes.full
    );
    const minimizedInterface = Array.isArray(abi) ? abi : [abi];
    return minimizedInterface.filter((i) => i.includes(config.functionName));
  }
}
function normalizeChainId(chainId2) {
  if (typeof chainId2 === "string")
    return Number.parseInt(
      chainId2,
      chainId2.trim().substring(0, 2) === "0x" ? 16 : 10
    );
  if (typeof chainId2 === "bigint")
    return Number(chainId2);
  return chainId2;
}
function isPlainArray(value) {
  return Array.isArray(value) && Object.keys(value).length === value.length;
}
function parseContractResult({
  abi,
  data,
  functionName
}) {
  var _a;
  if (data && isPlainArray(data)) {
    const iface = Contract.getInterface(abi);
    const fragment = iface.getFunction(functionName);
    const isTuple = (((_a = fragment.outputs) == null ? void 0 : _a.length) || 0) > 1;
    const data_ = isTuple ? data : [data];
    const encodedResult = iface.encodeFunctionResult(functionName, data_);
    const decodedResult = iface.decodeFunctionResult(
      functionName,
      encodedResult
    );
    return isTuple ? decodedResult : decodedResult[0];
  }
  return data;
}
var erc20ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var erc20ABI_bytes32 = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var erc721ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "ApprovalForAll",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        name: "approved",
        type: "bool"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "payable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "getApproved",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address"
      }
    ]
  },
  {
    type: "function",
    name: "isApprovedForAll",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "operator",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "ownerOf",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "owner",
        type: "address"
      }
    ]
  },
  {
    type: "function",
    name: "safeTransferFrom",
    stateMutability: "payable",
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "safeTransferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "id",
        type: "uint256"
      },
      {
        name: "data",
        type: "bytes"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "setApprovalForAll",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "operator",
        type: "address"
      },
      {
        name: "approved",
        type: "bool"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "tokenByIndex",
    stateMutability: "view",
    inputs: [
      {
        name: "index",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "tokenByIndex",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "index",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "tokenURI",
    stateMutability: "view",
    inputs: [
      {
        name: "tokenId",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "payable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "tokeId",
        type: "uint256"
      }
    ],
    outputs: []
  }
];
var multicallABI = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var erc4626ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: false,
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "asset",
    outputs: [
      {
        name: "assetTokenAddress",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "convertToAssets",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "convertToShares",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      }
    ],
    name: "deposit",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "caller",
        type: "address"
      }
    ],
    name: "maxDeposit",
    outputs: [
      {
        name: "maxAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "caller",
        type: "address"
      }
    ],
    name: "maxMint",
    outputs: [
      {
        name: "maxShares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "maxRedeem",
    outputs: [
      {
        name: "maxShares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "maxWithdraw",
    outputs: [
      {
        name: "maxAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewDeposit",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewMint",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewRedeem",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewWithdraw",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "shares",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      },
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "redeem",
    outputs: [
      {
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "totalAssets",
    outputs: [
      {
        name: "totalManagedAssets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        name: "to",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "from",
        type: "address"
      },
      {
        name: "to",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "assets",
        type: "uint256"
      },
      {
        name: "receiver",
        type: "address"
      },
      {
        name: "owner",
        type: "address"
      }
    ],
    name: "withdraw",
    outputs: [
      {
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var Connector = class extends import_eventemitter3.default {
  constructor({
    chains = defaultChains,
    options
  }) {
    super();
    this.chains = chains;
    this.options = options;
  }
  getBlockExplorerUrls(chain2) {
    var _a;
    const { default: blockExplorer, ...blockExplorers } = (_a = chain2.blockExplorers) != null ? _a : {};
    if (blockExplorer)
      return [
        blockExplorer.url,
        ...Object.values(blockExplorers).map((x) => x.url)
      ];
  }
  isChainUnsupported(chainId2) {
    return !this.chains.some((x) => x.id === chainId2);
  }
};
var _provider;
var _switchingChains;
var InjectedConnector = class extends Connector {
  constructor({
    chains,
    options: options_
  } = {}) {
    const options = {
      shimDisconnect: true,
      shimChainChangedDisconnect: true,
      ...options_
    };
    super({ chains, options });
    this.ready = typeof window != "undefined" && !!window.ethereum;
    __privateAdd(this, _provider, void 0);
    __privateAdd(this, _switchingChains, void 0);
    this.shimDisconnectKey = "injected.shimDisconnect";
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: (0, import_utils.getAddress)(accounts[0])
        });
    };
    this.onChainChanged = (chainId2) => {
      const id = normalizeChainId(chainId2);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", { chain: { id, unsupported } });
    };
    this.onDisconnect = () => {
      var _a, _b, _c;
      if (((_a = this.options) == null ? void 0 : _a.shimChainChangedDisconnect) && __privateGet(this, _switchingChains)) {
        __privateSet(this, _switchingChains, false);
        return;
      }
      this.emit("disconnect");
      if ((_b = this.options) == null ? void 0 : _b.shimDisconnect)
        (_c = getClient().storage) == null ? void 0 : _c.removeItem(this.shimDisconnectKey);
    };
    let name = "Injected";
    const overrideName = options.name;
    if (typeof overrideName === "string")
      name = overrideName;
    else if (typeof window !== "undefined") {
      const detectedName = getInjectedName(window.ethereum);
      if (overrideName)
        name = overrideName(detectedName);
      else
        name = typeof detectedName === "string" ? detectedName : detectedName[0];
    }
    this.id = "injected";
    this.name = name;
  }
  async connect({ chainId: chainId2 } = {}) {
    var _a, _b;
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      const account = await this.getAccount();
      let id = await this.getChainId();
      let unsupported = this.isChainUnsupported(id);
      if (chainId2 && id !== chainId2) {
        const chain2 = await this.switchChain(chainId2);
        id = chain2.id;
        unsupported = this.isChainUnsupported(id);
      }
      if ((_a = this.options) == null ? void 0 : _a.shimDisconnect)
        (_b = getClient().storage) == null ? void 0 : _b.setItem(this.shimDisconnectKey, true);
      return { account, chain: { id, unsupported }, provider };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableError(error);
      throw error;
    }
  }
  async disconnect() {
    var _a, _b;
    const provider = await this.getProvider();
    if (!(provider == null ? void 0 : provider.removeListener))
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if ((_a = this.options) == null ? void 0 : _a.shimDisconnect)
      (_b = getClient().storage) == null ? void 0 : _b.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    return (0, import_utils.getAddress)(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({ method: "eth_chainId" }).then(normalizeChainId);
  }
  async getProvider() {
    if (typeof window !== "undefined" && !!window.ethereum)
      __privateSet(this, _provider, window.ethereum);
    return __privateGet(this, _provider);
  }
  async getSigner({ chainId: chainId2 } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    return new lib_exports20.Web3Provider(
      provider,
      chainId2
    ).getSigner(account);
  }
  async isAuthorized() {
    var _a, _b;
    try {
      if (((_a = this.options) == null ? void 0 : _a.shimDisconnect) && !((_b = getClient().storage) == null ? void 0 : _b.getItem(this.shimDisconnectKey)))
        return false;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      const account = accounts[0];
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId2) {
    var _a, _b, _c, _d, _e;
    if ((_a = this.options) == null ? void 0 : _a.shimChainChangedDisconnect)
      __privateSet(this, _switchingChains, true);
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id = (0, import_utils.hexValue)(chainId2);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id }]
      });
      return (_b = this.chains.find((x) => x.id === chainId2)) != null ? _b : {
        id: chainId2,
        name: `Chain ${id}`,
        network: `${id}`,
        rpcUrls: { default: "" }
      };
    } catch (error) {
      const chain2 = this.chains.find((x) => x.id === chainId2);
      if (!chain2)
        throw new ChainNotConfiguredError({ chainId: chainId2, connectorId: this.id });
      if (error.code === 4902 || ((_d = (_c = error == null ? void 0 : error.data) == null ? void 0 : _c.originalError) == null ? void 0 : _d.code) === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id,
                chainName: chain2.name,
                nativeCurrency: chain2.nativeCurrency,
                rpcUrls: [(_e = chain2.rpcUrls.public) != null ? _e : chain2.rpcUrls.default],
                blockExplorerUrls: this.getBlockExplorerUrls(chain2)
              }
            ]
          });
          return chain2;
        } catch (addError) {
          if (this.isUserRejectedRequestError(addError))
            throw new UserRejectedRequestError(error);
          throw new AddChainError();
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
_provider = /* @__PURE__ */ new WeakMap();
_switchingChains = /* @__PURE__ */ new WeakMap();
var noopStorage = {
  getItem: (_key) => "",
  setItem: (_key, _value) => null,
  removeItem: (_key) => null
};
function createStorage({
  storage,
  key: prefix = "wagmi"
}) {
  return {
    ...storage,
    getItem: (key, defaultState = null) => {
      const value = storage.getItem(`${prefix}.${key}`);
      try {
        return value ? JSON.parse(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem(`${prefix}.${key}`);
      } else {
        try {
          storage.setItem(`${prefix}.${key}`, JSON.stringify(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key) => storage.removeItem(`${prefix}.${key}`)
  };
}
var storeKey = "store";
var _isAutoConnecting;
var _lastUsedConnector;
var _addEffects;
var addEffects_fn;
var Client = class {
  constructor({
    autoConnect = false,
    connectors = [new InjectedConnector()],
    provider,
    storage = createStorage({
      storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }),
    logger = {
      warn: console.warn
    },
    webSocketProvider
  }) {
    var _a, _b, _c;
    __privateAdd(this, _addEffects);
    this.providers = /* @__PURE__ */ new Map();
    this.webSocketProviders = /* @__PURE__ */ new Map();
    __privateAdd(this, _isAutoConnecting, void 0);
    __privateAdd(this, _lastUsedConnector, void 0);
    this.config = {
      autoConnect,
      connectors,
      logger,
      provider,
      storage,
      webSocketProvider
    };
    let status = "disconnected";
    let chainId2;
    if (autoConnect) {
      try {
        const rawState = storage.getItem(storeKey, "");
        const data = (_b = (_a = JSON.parse(rawState || "{}")) == null ? void 0 : _a.state) == null ? void 0 : _b.data;
        status = (data == null ? void 0 : data.account) ? "reconnecting" : "connecting";
        chainId2 = (_c = data == null ? void 0 : data.chain) == null ? void 0 : _c.id;
      } catch (_error) {
      }
    }
    this.store = createStore(
      subscribeWithSelector(
        persist(
          () => ({
            connectors: typeof connectors === "function" ? connectors() : connectors,
            provider: this.getProvider({ chainId: chainId2 }),
            status,
            webSocketProvider: this.getWebSocketProvider({ chainId: chainId2 })
          }),
          {
            name: storeKey,
            getStorage: () => storage,
            partialize: (state) => {
              var _a2, _b2;
              return {
                ...autoConnect && {
                  data: {
                    account: (_a2 = state == null ? void 0 : state.data) == null ? void 0 : _a2.account,
                    chain: (_b2 = state == null ? void 0 : state.data) == null ? void 0 : _b2.chain
                  }
                },
                chains: state == null ? void 0 : state.chains
              };
            },
            version: 1
          }
        )
      )
    );
    this.storage = storage;
    __privateSet(this, _lastUsedConnector, storage == null ? void 0 : storage.getItem("wallet"));
    __privateMethod(this, _addEffects, addEffects_fn).call(this);
    if (autoConnect && typeof window !== "undefined")
      setTimeout(async () => await this.autoConnect(), 0);
  }
  get chains() {
    return this.store.getState().chains;
  }
  get connectors() {
    return this.store.getState().connectors;
  }
  get connector() {
    return this.store.getState().connector;
  }
  get data() {
    return this.store.getState().data;
  }
  get error() {
    return this.store.getState().error;
  }
  get lastUsedChainId() {
    var _a, _b;
    return (_b = (_a = this.data) == null ? void 0 : _a.chain) == null ? void 0 : _b.id;
  }
  get provider() {
    return this.store.getState().provider;
  }
  get status() {
    return this.store.getState().status;
  }
  get subscribe() {
    return this.store.subscribe;
  }
  get webSocketProvider() {
    return this.store.getState().webSocketProvider;
  }
  setState(updater) {
    const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }
  clearState() {
    this.setState((x) => ({
      ...x,
      chains: void 0,
      connector: void 0,
      data: void 0,
      error: void 0,
      status: "disconnected"
    }));
  }
  async destroy() {
    var _a, _b;
    if (this.connector)
      await ((_b = (_a = this.connector).disconnect) == null ? void 0 : _b.call(_a));
    __privateSet(this, _isAutoConnecting, false);
    this.clearState();
    this.store.destroy();
  }
  async autoConnect() {
    if (__privateGet(this, _isAutoConnecting))
      return;
    __privateSet(this, _isAutoConnecting, true);
    this.setState((x) => {
      var _a;
      return {
        ...x,
        status: ((_a = x.data) == null ? void 0 : _a.account) ? "reconnecting" : "connecting"
      };
    });
    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(
      (x) => x.id === __privateGet(this, _lastUsedConnector) ? -1 : 1
    ) : this.connectors;
    let connected = false;
    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized)
        continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized)
        continue;
      const data = await connector.connect();
      this.setState((x) => ({
        ...x,
        connector,
        chains: connector == null ? void 0 : connector.chains,
        data,
        status: "connected"
      }));
      connected = true;
      break;
    }
    if (!connected)
      this.setState((x) => ({
        ...x,
        data: void 0,
        status: "disconnected"
      }));
    __privateSet(this, _isAutoConnecting, false);
    return this.data;
  }
  getProvider({ bust, chainId: chainId2 } = {}) {
    let provider_ = this.providers.get(chainId2 != null ? chainId2 : -1);
    if (provider_ && !bust)
      return provider_;
    const { provider } = this.config;
    provider_ = typeof provider === "function" ? provider({ chainId: chainId2 }) : provider;
    this.providers.set(chainId2 != null ? chainId2 : -1, provider_);
    return provider_;
  }
  getWebSocketProvider({
    bust,
    chainId: chainId2
  } = {}) {
    let webSocketProvider_ = this.webSocketProviders.get(chainId2 != null ? chainId2 : -1);
    if (webSocketProvider_ && !bust)
      return webSocketProvider_;
    const { webSocketProvider } = this.config;
    webSocketProvider_ = typeof webSocketProvider === "function" ? webSocketProvider({ chainId: chainId2 }) : webSocketProvider;
    if (webSocketProvider_)
      this.webSocketProviders.set(chainId2 != null ? chainId2 : -1, webSocketProvider_);
    return webSocketProvider_;
  }
  setLastUsedConnector(lastUsedConnector = null) {
    var _a;
    (_a = this.storage) == null ? void 0 : _a.setItem("wallet", lastUsedConnector);
  }
};
_isAutoConnecting = /* @__PURE__ */ new WeakMap();
_lastUsedConnector = /* @__PURE__ */ new WeakMap();
_addEffects = /* @__PURE__ */ new WeakSet();
addEffects_fn = function() {
  const onChange = (data) => {
    this.setState((x) => ({
      ...x,
      data: { ...x.data, ...data }
    }));
  };
  const onDisconnect = () => {
    this.clearState();
  };
  const onError = (error) => {
    this.setState((x) => ({ ...x, error }));
  };
  this.store.subscribe(
    ({ connector }) => connector,
    (connector, prevConnector) => {
      var _a, _b, _c, _d, _e, _f;
      (_a = prevConnector == null ? void 0 : prevConnector.off) == null ? void 0 : _a.call(prevConnector, "change", onChange);
      (_b = prevConnector == null ? void 0 : prevConnector.off) == null ? void 0 : _b.call(prevConnector, "disconnect", onDisconnect);
      (_c = prevConnector == null ? void 0 : prevConnector.off) == null ? void 0 : _c.call(prevConnector, "error", onError);
      if (!connector)
        return;
      (_d = connector.on) == null ? void 0 : _d.call(connector, "change", onChange);
      (_e = connector.on) == null ? void 0 : _e.call(connector, "disconnect", onDisconnect);
      (_f = connector.on) == null ? void 0 : _f.call(connector, "error", onError);
    }
  );
  const { provider, webSocketProvider } = this.config;
  const subscribeProvider = typeof provider === "function";
  const subscribeWebSocketProvider = typeof webSocketProvider === "function";
  if (subscribeProvider || subscribeWebSocketProvider)
    this.store.subscribe(
      ({ data }) => {
        var _a;
        return (_a = data == null ? void 0 : data.chain) == null ? void 0 : _a.id;
      },
      (chainId2) => {
        this.setState((x) => ({
          ...x,
          provider: this.getProvider({ bust: true, chainId: chainId2 }),
          webSocketProvider: this.getWebSocketProvider({
            bust: true,
            chainId: chainId2
          })
        }));
      }
    );
};
var client;
function createClient(config) {
  const client_ = new Client(config);
  client = client_;
  return client_;
}
function getClient() {
  if (!client) {
    throw new Error(
      "No wagmi client found. Ensure you have set up a client: https://wagmi.sh/docs/client"
    );
  }
  return client;
}
async function connect({
  chainId: chainId2,
  connector
}) {
  const client2 = getClient();
  const activeConnector = client2.connector;
  if (connector.id === (activeConnector == null ? void 0 : activeConnector.id))
    throw new ConnectorAlreadyConnectedError();
  try {
    client2.setState((x) => ({ ...x, status: "connecting" }));
    const data = await connector.connect({ chainId: chainId2 });
    client2.setLastUsedConnector(connector.id);
    client2.setState((x) => ({
      ...x,
      connector,
      chains: connector == null ? void 0 : connector.chains,
      data,
      status: "connected"
    }));
    client2.storage.setItem("connected", true);
    return { ...data, connector };
  } catch (err) {
    client2.setState((x) => {
      return {
        ...x,
        status: x.connector ? "connected" : "disconnected"
      };
    });
    throw err;
  }
}
async function disconnect() {
  const client2 = getClient();
  if (client2.connector)
    await client2.connector.disconnect();
  client2.clearState();
  client2.storage.removeItem("connected");
}
async function fetchToken({
  address,
  chainId: chainId2,
  formatUnits: units2 = "ether"
}) {
  async function fetchToken_({ abi }) {
    const erc20Config = { address, abi, chainId: chainId2 };
    const [decimals, name, symbol, totalSupply] = await readContracts({
      allowFailure: false,
      contracts: [
        { ...erc20Config, functionName: "decimals" },
        { ...erc20Config, functionName: "name" },
        { ...erc20Config, functionName: "symbol" },
        { ...erc20Config, functionName: "totalSupply" }
      ]
    });
    return {
      address,
      decimals,
      name,
      symbol,
      totalSupply: {
        formatted: (0, import_utils5.formatUnits)(totalSupply, units2),
        value: totalSupply
      }
    };
  }
  try {
    return await fetchToken_({ abi: erc20ABI });
  } catch (err) {
    if (err instanceof ContractResultDecodeError) {
      const { name, symbol, ...rest } = await fetchToken_({
        abi: erc20ABI_bytes32
      });
      return {
        name: (0, import_utils5.parseBytes32String)(name),
        symbol: (0, import_utils5.parseBytes32String)(symbol),
        ...rest
      };
    }
    throw err;
  }
}
function getContract({
  address,
  abi,
  signerOrProvider
}) {
  return new Contract(
    address,
    abi,
    signerOrProvider
  );
}
async function prepareWriteContract({
  abi,
  address,
  args,
  chainId: chainId2,
  functionName,
  overrides,
  signer: signer_
}) {
  const signer = signer_ != null ? signer_ : await fetchSigner({ chainId: chainId2 });
  if (!signer)
    throw new ConnectorNotFoundError();
  if (chainId2)
    assertActiveChain({ chainId: chainId2, signer });
  const contract = getContract({
    address,
    abi,
    signerOrProvider: signer
  });
  const normalizedFunctionName = normalizeFunctionName({
    contract,
    functionName,
    args
  });
  const populateTransactionFn = contract.populateTransaction[normalizedFunctionName];
  if (!populateTransactionFn)
    throw new ContractMethodDoesNotExistError({
      address,
      functionName: normalizedFunctionName
    });
  const params = [...args != null ? args : [], ...overrides ? [overrides] : []];
  const unsignedTransaction = await populateTransactionFn(
    ...params
  );
  const gasLimit = unsignedTransaction.gasLimit || await signer.estimateGas(unsignedTransaction);
  const minimizedAbi = minimizeContractInterface({
    abi,
    functionName
  });
  return {
    abi: minimizedAbi,
    address,
    chainId: chainId2,
    functionName,
    mode: "prepared",
    request: {
      ...unsignedTransaction,
      gasLimit
    }
  };
}
function getProvider({
  chainId: chainId2
} = {}) {
  const client2 = getClient();
  if (chainId2)
    return client2.getProvider({ chainId: chainId2 }) || client2.provider;
  return client2.provider;
}
function getWebSocketProvider({
  chainId: chainId2
} = {}) {
  const client2 = getClient();
  if (chainId2)
    return client2.getWebSocketProvider({ chainId: chainId2 }) || client2.webSocketProvider;
  return client2.webSocketProvider;
}
function watchProvider(args, callback) {
  const client2 = getClient();
  const handleChange = async () => callback(getProvider(args));
  const unsubscribe = client2.subscribe(({ provider }) => provider, handleChange);
  return unsubscribe;
}
function watchWebSocketProvider(args, callback) {
  const client2 = getClient();
  const handleChange = async () => callback(getWebSocketProvider(args));
  const unsubscribe = client2.subscribe(
    ({ webSocketProvider }) => webSocketProvider,
    handleChange
  );
  return unsubscribe;
}
async function multicall({
  allowFailure = true,
  chainId: chainId2,
  contracts,
  overrides
}) {
  const provider = getProvider({ chainId: chainId2 });
  if (!provider.chains)
    throw new ProviderChainsNotFound();
  const chain2 = provider.chains.find((chain3) => chain3.id === chainId2) || provider.chains[0];
  if (!chain2)
    throw new ProviderChainsNotFound();
  if (!(chain2 == null ? void 0 : chain2.multicall))
    throw new ChainDoesNotSupportMulticallError({ chain: chain2 });
  if (typeof (overrides == null ? void 0 : overrides.blockTag) === "number" && (overrides == null ? void 0 : overrides.blockTag) < chain2.multicall.blockCreated)
    throw new ChainDoesNotSupportMulticallError({
      blockNumber: overrides == null ? void 0 : overrides.blockTag,
      chain: chain2
    });
  const multicallContract = getContract({
    address: chain2.multicall.address,
    abi: multicallABI,
    signerOrProvider: provider
  });
  const calls = contracts.map(
    ({ address, abi, functionName, ...config }) => {
      const { args } = config || {};
      const contract = getContract({ address, abi });
      const params2 = args != null ? args : [];
      const normalizedFunctionName = normalizeFunctionName({
        contract,
        functionName,
        args
      });
      try {
        const contractFunction = contract[normalizedFunctionName];
        if (!contractFunction)
          logWarn(
            `"${normalizedFunctionName}" is not in the interface for contract "${address}"`
          );
        const callData = contract.interface.encodeFunctionData(
          normalizedFunctionName,
          params2
        );
        return {
          target: address,
          allowFailure,
          callData
        };
      } catch (err) {
        if (!allowFailure)
          throw err;
        return {
          target: address,
          allowFailure,
          callData: "0x"
        };
      }
    }
  );
  const params = [...[calls], ...overrides ? [overrides] : []];
  const results = await multicallContract.aggregate3(
    ...params
  );
  return results.map(({ returnData, success }, i) => {
    const { address, abi, args, functionName } = contracts[i];
    const contract = getContract({
      address,
      abi
    });
    const normalizedFunctionName = normalizeFunctionName({
      contract,
      functionName,
      args
    });
    if (!success) {
      let error;
      try {
        contract.interface.decodeFunctionResult(
          normalizedFunctionName,
          returnData
        );
      } catch (err) {
        error = new ContractMethodRevertedError({
          address,
          args,
          chainId: chain2.id,
          functionName: normalizedFunctionName,
          errorMessage: err.message
        });
        if (!allowFailure)
          throw error;
        logWarn(error.message);
      }
      return null;
    }
    if (returnData === "0x") {
      const error = new ContractMethodNoResultError({
        address,
        args,
        chainId: chain2.id,
        functionName: normalizedFunctionName
      });
      if (!allowFailure)
        throw error;
      logWarn(error.message);
      return null;
    }
    try {
      const result = contract.interface.decodeFunctionResult(
        normalizedFunctionName,
        returnData
      );
      return Array.isArray(result) && result.length === 1 ? result[0] : result;
    } catch (err) {
      const error = new ContractResultDecodeError({
        address,
        args,
        chainId: chain2.id,
        functionName: normalizedFunctionName,
        errorMessage: err.message
      });
      if (!allowFailure)
        throw error;
      logWarn(error.message);
      return null;
    }
  });
}
async function readContract({
  address,
  args,
  chainId: chainId2,
  abi,
  functionName,
  overrides
}) {
  const provider = getProvider({ chainId: chainId2 });
  const contract = getContract({
    address,
    abi,
    signerOrProvider: provider
  });
  const normalizedFunctionName = normalizeFunctionName({
    contract,
    functionName,
    args
  });
  const contractFunction = contract[normalizedFunctionName];
  if (!contractFunction)
    throw new ContractMethodDoesNotExistError({
      address,
      functionName: normalizedFunctionName
    });
  const params = [...args != null ? args : [], ...overrides ? [overrides] : []];
  return contractFunction == null ? void 0 : contractFunction(...params);
}
async function readContracts({
  allowFailure = true,
  contracts,
  overrides
}) {
  try {
    const provider = getProvider();
    const contractsByChainId = contracts.reduce((contracts2, contract, index) => {
      var _a;
      const chainId2 = (_a = contract.chainId) != null ? _a : provider.network.chainId;
      return {
        ...contracts2,
        [chainId2]: [...contracts2[chainId2] || [], { contract, index }]
      };
    }, {});
    const promises = () => Object.entries(contractsByChainId).map(
      ([chainId2, contracts2]) => multicall({
        allowFailure,
        chainId: parseInt(chainId2),
        contracts: contracts2.map(({ contract }) => contract),
        overrides
      })
    );
    let multicallResults;
    if (allowFailure) {
      multicallResults = (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return result.value;
        if (result.reason instanceof ChainDoesNotSupportMulticallError) {
          logWarn(result.reason.message);
          throw result.reason;
        }
        return null;
      }).flat();
    } else {
      multicallResults = (await Promise.all(promises())).flat();
    }
    const resultIndexes = Object.values(contractsByChainId).map((contracts2) => contracts2.map(({ index }) => index)).flat();
    return multicallResults.reduce((results, result, index) => {
      if (results)
        results[resultIndexes[index]] = result;
      return results;
    }, []);
  } catch (err) {
    if (err instanceof ContractResultDecodeError)
      throw err;
    if (err instanceof ContractMethodNoResultError)
      throw err;
    if (err instanceof ContractMethodRevertedError)
      throw err;
    const promises = () => contracts.map(
      (contract) => readContract({ ...contract, overrides })
    );
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result, i) => {
        if (result.status === "fulfilled")
          return result.value;
        const { address, args, chainId: chainId2, functionName } = contracts[i];
        const error = new ContractMethodRevertedError({
          address,
          functionName,
          chainId: chainId2 != null ? chainId2 : mainnet.id,
          args,
          errorMessage: result.reason
        });
        logWarn(error.message);
        return null;
      });
    return await Promise.all(promises());
  }
}
async function fetchBlockNumber({
  chainId: chainId2
} = {}) {
  const provider = getProvider({ chainId: chainId2 });
  const blockNumber = await provider.getBlockNumber();
  return blockNumber;
}
async function fetchTransaction({
  chainId: chainId2,
  hash
}) {
  const provider = getProvider({ chainId: chainId2 });
  return provider.getTransaction(hash);
}
async function fetchEnsAddress({
  chainId: chainId2,
  name
}) {
  const provider = getProvider({ chainId: chainId2 });
  const address = await provider.resolveName(name);
  try {
    return address ? (0, import_utils7.getAddress)(address) : null;
  } catch (_error) {
    return null;
  }
}
async function fetchEnsAvatar({
  address,
  chainId: chainId2
}) {
  const provider = getProvider({ chainId: chainId2 });
  const avatar = await provider.getAvatar(address);
  return avatar;
}
async function fetchEnsName({
  address,
  chainId: chainId2
}) {
  const provider = getProvider({ chainId: chainId2 });
  return provider.lookupAddress((0, import_utils8.getAddress)(address));
}
async function fetchEnsResolver({
  chainId: chainId2,
  name
}) {
  const provider = getProvider({ chainId: chainId2 });
  const resolver = await provider.getResolver(name);
  return resolver;
}
async function prepareSendTransaction({
  chainId: chainId2,
  request,
  signer: signer_
}) {
  const signer = signer_ != null ? signer_ : await fetchSigner({ chainId: chainId2 });
  if (!signer)
    throw new ConnectorNotFoundError();
  if (chainId2)
    assertActiveChain({ chainId: chainId2, signer });
  const [to, gasLimit] = await Promise.all([
    (0, import_utils6.isAddress)(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({ name: request.to }),
    request.gasLimit ? Promise.resolve(request.gasLimit) : signer.estimateGas(request)
  ]);
  if (!to)
    throw new Error("Could not resolve ENS name");
  return {
    ...chainId2 ? { chainId: chainId2 } : {},
    request: { ...request, gasLimit, to },
    mode: "prepared"
  };
}
async function sendTransaction({
  chainId: chainId2,
  mode,
  request
}) {
  var _a;
  const signer = await fetchSigner();
  if (!signer)
    throw new ConnectorNotFoundError();
  if (mode === "prepared") {
    if (!request.gasLimit)
      throw new Error("`gasLimit` is required");
    if (!request.to)
      throw new Error("`to` is required");
  }
  if (chainId2)
    assertActiveChain({ chainId: chainId2, signer });
  try {
    const uncheckedSigner = (_a = signer.connectUnchecked) == null ? void 0 : _a.call(signer);
    const { hash, wait } = await (uncheckedSigner != null ? uncheckedSigner : signer).sendTransaction(
      request
    );
    return { hash, wait };
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function waitForTransaction({
  chainId: chainId2,
  confirmations,
  hash,
  timeout,
  wait: wait_
}) {
  let promise;
  if (hash) {
    const provider = getProvider({ chainId: chainId2 });
    promise = provider.waitForTransaction(hash, confirmations, timeout);
  } else if (wait_)
    promise = wait_(confirmations);
  else
    throw new Error("hash or wait is required");
  return promise;
}
async function writeContract({
  address,
  args,
  chainId: chainId2,
  abi,
  functionName,
  mode,
  overrides,
  request: request_
}) {
  const signer = await fetchSigner();
  if (!signer)
    throw new ConnectorNotFoundError();
  if (chainId2)
    assertActiveChain({ chainId: chainId2, signer });
  if (mode === "prepared") {
    if (!request_)
      throw new Error("`request` is required");
  }
  const request = mode === "recklesslyUnprepared" ? (await prepareWriteContract({
    address,
    args,
    chainId: chainId2,
    abi,
    functionName,
    overrides
  })).request : request_;
  const transaction = await sendTransaction({
    request,
    mode: "prepared"
  });
  return transaction;
}
async function fetchBalance({
  address,
  chainId: chainId2,
  formatUnits: unit,
  token
}) {
  var _a, _b, _c, _d, _e;
  const client2 = getClient();
  const provider = getProvider({ chainId: chainId2 });
  if (token) {
    const fetchContractBalance = async ({ abi }) => {
      const erc20Config = { abi, address: token, chainId: chainId2 };
      const [value2, decimals, symbol] = await readContracts({
        allowFailure: false,
        contracts: [
          {
            ...erc20Config,
            functionName: "balanceOf",
            args: [address]
          },
          { ...erc20Config, functionName: "decimals" },
          { ...erc20Config, functionName: "symbol" }
        ]
      });
      return {
        decimals,
        formatted: (0, import_utils4.formatUnits)(value2 != null ? value2 : "0", unit != null ? unit : decimals),
        symbol,
        value: value2
      };
    };
    try {
      return await fetchContractBalance({ abi: erc20ABI });
    } catch (err) {
      if (err instanceof ContractResultDecodeError) {
        const { symbol, ...rest } = await fetchContractBalance({
          abi: erc20ABI_bytes32
        });
        return {
          symbol: (0, import_utils4.parseBytes32String)(symbol),
          ...rest
        };
      }
      throw err;
    }
  }
  const chains = [...client2.provider.chains || [], ...(_a = client2.chains) != null ? _a : []];
  const value = await provider.getBalance(address);
  const chain2 = chains.find((x) => x.id === provider.network.chainId);
  return {
    decimals: (_c = (_b = chain2 == null ? void 0 : chain2.nativeCurrency) == null ? void 0 : _b.decimals) != null ? _c : 18,
    formatted: (0, import_utils4.formatUnits)(value != null ? value : "0", unit != null ? unit : "ether"),
    symbol: (_e = (_d = chain2 == null ? void 0 : chain2.nativeCurrency) == null ? void 0 : _d.symbol) != null ? _e : "ETH",
    value
  };
}
async function fetchSigner({
  chainId: chainId2
} = {}) {
  var _a, _b;
  const client2 = getClient();
  const signer = await ((_b = (_a = client2.connector) == null ? void 0 : _a.getSigner) == null ? void 0 : _b.call(_a, { chainId: chainId2 })) || null;
  return signer;
}
function getAccount() {
  const { data, connector, status } = getClient();
  switch (status) {
    case "connected":
      return {
        address: data == null ? void 0 : data.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data == null ? void 0 : data.account,
        connector,
        isConnected: !!(data == null ? void 0 : data.account),
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork() {
  var _a, _b, _c, _d, _e;
  const client2 = getClient();
  const chainId2 = (_b = (_a = client2.data) == null ? void 0 : _a.chain) == null ? void 0 : _b.id;
  const activeChains = (_c = client2.chains) != null ? _c : [];
  const activeChain = (_d = [...client2.provider.chains || [], ...activeChains].find(
    (x) => x.id === chainId2
  )) != null ? _d : {
    id: chainId2,
    name: `Chain ${chainId2}`,
    network: `${chainId2}`,
    rpcUrls: { default: "" }
  };
  return {
    chain: chainId2 ? {
      ...activeChain,
      ...(_e = client2.data) == null ? void 0 : _e.chain,
      id: chainId2
    } : void 0,
    chains: activeChains
  };
}
async function signMessage(args) {
  try {
    const signer = await fetchSigner();
    if (!signer)
      throw new ConnectorNotFoundError();
    return await signer.signMessage(
      args.message
    );
  } catch (error) {
    if (error.code === 4001)
      throw new UserRejectedRequestError(error);
    throw error;
  }
}
async function signTypedData({
  domain,
  types,
  value
}) {
  const signer = await fetchSigner();
  if (!signer)
    throw new ConnectorNotFoundError();
  const { chainId: chainId_ } = domain;
  const chainId2 = chainId_ ? normalizeChainId(chainId_) : void 0;
  if (chainId2)
    assertActiveChain({ chainId: chainId2, signer });
  return signer._signTypedData(
    domain,
    types,
    value
  );
}
async function switchNetwork({
  chainId: chainId2
}) {
  const { connector } = getClient();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return connector.switchChain(chainId2);
}
function watchAccount(callback, { selector = (x) => x } = {}) {
  const client2 = getClient();
  const handleChange = () => callback(getAccount());
  const unsubscribe = client2.subscribe(
    ({ data, connector, status }) => selector({
      address: data == null ? void 0 : data.account,
      connector,
      status
    }),
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
function watchNetwork(callback, { selector = (x) => x } = {}) {
  const client2 = getClient();
  const handleChange = () => callback(getNetwork());
  const unsubscribe = client2.subscribe(
    ({ data, chains }) => {
      var _a;
      return selector({ chainId: (_a = data == null ? void 0 : data.chain) == null ? void 0 : _a.id, chains });
    },
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
function watchSigner({ chainId: chainId2 }, callback) {
  const client2 = getClient();
  const handleChange = async () => callback(await fetchSigner({ chainId: chainId2 }));
  const unsubscribe = client2.subscribe(
    ({ data, connector }) => {
      var _a;
      return {
        account: data == null ? void 0 : data.account,
        chainId: (_a = data == null ? void 0 : data.chain) == null ? void 0 : _a.id,
        connector
      };
    },
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
async function fetchFeeData({
  chainId: chainId2,
  formatUnits: units2 = "wei"
} = {}) {
  const provider = getProvider({ chainId: chainId2 });
  const feeData = await provider.getFeeData();
  const formatted = {
    gasPrice: feeData.gasPrice ? (0, import_utils9.formatUnits)(feeData.gasPrice, units2) : null,
    maxFeePerGas: feeData.maxFeePerGas ? (0, import_utils9.formatUnits)(feeData.maxFeePerGas, units2) : null,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? (0, import_utils9.formatUnits)(feeData.maxPriorityFeePerGas, units2) : null
  };
  return { ...feeData, formatted };
}
var RpcError = class extends Error {
  constructor(code, message, internal, data) {
    if (!Number.isInteger(code))
      throw new Error('"code" must be an integer.');
    if (!message || typeof message !== "string")
      throw new Error('"message" must be a nonempty string.');
    super(message);
    this.code = code;
    this.data = data;
    this.internal = internal;
  }
};
var ProviderRpcError = class extends RpcError {
  constructor(code, message, internal, data) {
    if (!(Number.isInteger(code) && code >= 1e3 && code <= 4999))
      throw new Error(
        '"code" must be an integer such that: 1000 <= code <= 4999'
      );
    super(code, message, internal, data);
  }
};
var AddChainError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "AddChainError";
    this.message = "Error adding chain";
  }
};
var ChainDoesNotSupportMulticallError = class extends Error {
  constructor({ blockNumber, chain: chain2 }) {
    super(
      `Chain "${chain2.name}" does not support multicall${blockNumber ? ` on block ${blockNumber}` : ""}.`
    );
    this.name = "ChainDoesNotSupportMulticall";
  }
};
var ChainMismatchError = class extends Error {
  constructor({
    activeChain,
    targetChain
  }) {
    super(
      `Chain mismatch: Expected "${targetChain}", received "${activeChain}".`
    );
    this.name = "ChainMismatchError";
  }
};
var ChainNotConfiguredError = class extends Error {
  constructor({
    chainId: chainId2,
    connectorId
  }) {
    super(`Chain "${chainId2}" not configured for connector "${connectorId}".`);
    this.name = "ChainNotConfigured";
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorAlreadyConnectedError";
    this.message = "Connector already connected";
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorNotFoundError";
    this.message = "Connector not found";
  }
};
var ContractMethodDoesNotExistError = class extends Error {
  constructor({
    address,
    chainId: chainId2,
    functionName
  }) {
    var _a;
    const { chains, network } = getProvider();
    const chain2 = chains == null ? void 0 : chains.find(({ id }) => id === (chainId2 || network.chainId));
    const blockExplorer = (_a = chain2 == null ? void 0 : chain2.blockExplorers) == null ? void 0 : _a.default;
    super(
      [
        `Function "${functionName}" on contract "${address}" does not exist.`,
        ...blockExplorer ? [
          "",
          `${blockExplorer == null ? void 0 : blockExplorer.name}: ${blockExplorer == null ? void 0 : blockExplorer.url}/address/${address}#readContract`
        ] : []
      ].join("\n")
    );
    this.name = "ContractMethodDoesNotExistError";
  }
};
var ContractMethodNoResultError = class extends Error {
  constructor({
    address,
    args,
    chainId: chainId2,
    functionName
  }) {
    super(
      [
        "Contract read returned an empty response. This could be due to any of the following:",
        `- The contract does not have the function "${functionName}",`,
        "- The parameters passed to the contract function may be invalid, or",
        "- The address is not a contract.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId: chainId2,
            args
          },
          null,
          2
        )
      ].join("\n")
    );
    this.name = "ContractMethodNoResultError";
  }
};
var ContractMethodRevertedError = class extends Error {
  constructor({
    address,
    args,
    chainId: chainId2,
    functionName,
    errorMessage
  }) {
    super(
      [
        "Contract method reverted with an error.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId: chainId2,
            args
          },
          null,
          2
        ),
        "",
        `Details: ${errorMessage}`
      ].join("\n")
    );
    this.name = "ContractMethodRevertedError";
  }
};
var ContractResultDecodeError = class extends Error {
  constructor({
    address,
    args,
    chainId: chainId2,
    functionName,
    errorMessage
  }) {
    super(
      [
        "Failed to decode contract function result.",
        "",
        `Config:`,
        JSON.stringify(
          {
            address,
            abi: "...",
            functionName,
            chainId: chainId2,
            args
          },
          null,
          2
        ),
        "",
        `Details: ${errorMessage}`
      ].join("\n")
    );
    this.name = "ContractResultDecodeError";
  }
};
var ProviderChainsNotFound = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ProviderChainsNotFound";
    this.message = [
      "No chains were found on the wagmi provider. Some functions that require a chain may not work.",
      "",
      "It is recommended to add a list of chains to the provider in `createClient`.",
      "",
      "Example:",
      "",
      "```",
      "import { getDefaultProvider } from 'ethers'",
      "import { chain, createClient } from 'wagmi'",
      "",
      "createClient({",
      "  provider: Object.assign(getDefaultProvider(), { chains: [chain.mainnet] })",
      "})",
      "```"
    ].join("\n");
  }
};
var ResourceUnavailableError = class extends RpcError {
  constructor(error) {
    super(-32002, "Resource unavailable", error);
    this.name = "ResourceUnavailable";
  }
};
var SwitchChainError = class extends ProviderRpcError {
  constructor(error) {
    super(4902, "Error switching chain", error);
    this.name = "SwitchChainError";
  }
};
var SwitchChainNotSupportedError = class extends Error {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    this.name = "SwitchChainNotSupportedError";
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor(error) {
    super(4001, "User rejected request", error);
    this.name = "UserRejectedRequestError";
  }
};

export {
  etherscanBlockExplorers,
  alchemyRpcUrls,
  infuraRpcUrls,
  publicRpcUrls,
  chainId,
  chain,
  allChains,
  defaultChains,
  defaultL2Chains,
  __privateGet,
  __privateAdd,
  __privateSet,
  __privateMethod,
  require_utils,
  configureChains,
  debounce,
  deepEqual,
  normalizeChainId,
  parseContractResult,
  erc20ABI,
  erc721ABI,
  erc4626ABI,
  Connector,
  InjectedConnector,
  createStorage,
  createClient,
  getClient,
  connect,
  disconnect,
  fetchToken,
  getContract,
  prepareWriteContract,
  getProvider,
  getWebSocketProvider,
  watchProvider,
  watchWebSocketProvider,
  readContract,
  readContracts,
  fetchBlockNumber,
  fetchTransaction,
  fetchEnsAddress,
  fetchEnsAvatar,
  fetchEnsName,
  fetchEnsResolver,
  prepareSendTransaction,
  sendTransaction,
  waitForTransaction,
  writeContract,
  fetchBalance,
  fetchSigner,
  getAccount,
  getNetwork,
  signMessage,
  signTypedData,
  switchNetwork,
  watchAccount,
  watchNetwork,
  watchSigner,
  fetchFeeData,
  RpcError,
  ProviderRpcError,
  AddChainError,
  ChainDoesNotSupportMulticallError,
  ChainMismatchError,
  ChainNotConfiguredError,
  ConnectorAlreadyConnectedError,
  ConnectorNotFoundError,
  ContractMethodDoesNotExistError,
  ContractMethodNoResultError,
  ContractMethodRevertedError,
  ContractResultDecodeError,
  ProviderChainsNotFound,
  ResourceUnavailableError,
  SwitchChainError,
  SwitchChainNotSupportedError,
  UserRejectedRequestError
};
//# sourceMappingURL=chunk-S5KFPPEZ.js.map
